version: 2
reference:
  images:
    builder: &builder
      - image: $BUILDER_IMAGE
        auth:
          username: $BUILDER_USERNAME
          password: $BUILDER_PASSWORD
  environment: &ENVIRONMENT
    SLACK_USERNAME: Vagrant
    SLACK_ICON: https://avatars.slack-edge.com/2017-10-17/257000837696_070f98107cdacc0486f6_36.png
    SLACK_TITLE: Vagrant Packaging
    PACKET_EXEC_PERSIST: 1
    PACKET_EXEC_DEVICE_NAME: installers
    PACKET_EXEC_DEVICE_SIZE: baremetal_1
    PACKET_EXEC_PREFER_FACILITIES: ewr1,iad1,ord1,dfw1,ams1,atl1,lax1,sea1
    PACKET_EXEC_OPERATING_SYSTEM: ubuntu_18_04
    PACKET_EXEC_PRE_BUILTINS: InstallVmware,InstallVagrant,InstallVagrantVmware
    PACKET_EXEC_SSH_KEY: /tmp/packet-ssh-key
  copypasta:
    default_workflow: &DEFAULT_WORKFLOW
      context: vagrant
      filters:
        branches:
          only: /build.*/
        tags:
          only: /.*/
    prerelease_workflow: &PRERELEASE_WORKFLOW
      context: vagrant
      filters:
        branches:
          only: /build.*/
        tags:
          only: /^v.+\+[a-z0-9]+$/
    release_workflow: &RELEASE_WORKFLOW
      context: vagrant
      filters:
        branches:
          ignore: /.*/
        tags:
          only: /^v\d+\.\d+\.\d+$/
    packet_setup: &PACKET_SETUP |-
      echo -e -n "${PACKET_SSH_KEY}" > "${PACKET_EXEC_SSH_KEY}"
      chmod 600 "${PACKET_EXEC_SSH_KEY}"
      unset PACKET_EXEC_PERSIST
      packet-exec run -- "mkdir -p '/tmp/${CIRCLE_WORKFLOW_ID}/'; touch '/tmp/${CIRCLE_WORKFLOW_ID}/${CIRCLE_BUILD_NUM}'"
    packet_failure: &PACKET_FAILURE |-
      echo -e -n "${PACKET_SSH_KEY}" > "${PACKET_EXEC_SSH_KEY}"
      chmod 600 "${PACKET_EXEC_SSH_KEY}"
      export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_BUILD_NUM}"
      unset PACKET_EXEC_PERSIST
      packet-exec run -- "touch '/tmp/${CIRCLE_WORKFLOW_ID}/.halt'"
    packet_cleanup: &PACKET_CLEANUP |-
      echo -e -n "${PACKET_SSH_KEY}" > "${PACKET_EXEC_SSH_KEY}"
      chmod 600 "${PACKET_EXEC_SSH_KEY}"
      export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_BUILD_NUM}"
      unset PACKET_EXEC_PERSIST
      packet-exec run -- "rm -f '/tmp/${CIRCLE_WORKFLOW_ID}/${CIRCLE_BUILD_NUM}'"
    packet_setup_step: &PACKET_SETUP_STEP
      run:
        name: Setup packet guest usage
        command: *PACKET_SETUP
    packet_failure_step: &PACKET_FAILURE_STEP
      run:
        name: Mark packet failure
        command: *PACKET_FAILURE
        when: on_fail
    packet_cleanup_step: &PACKET_CLEANUP_STEP
      run:
        name: Clean packet guests
        when: always
        command: *PACKET_CLEANUP
    upload_substrates: &UPLOAD_SUBSTRATES
      run:
        name: Upload substrates
        command: |
          set +e
          sha=$(git rev-parse --short "${CIRCLE_SHA1}")
          s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${sha}/"
          mkdir -p substrate-assets
          pushd substrate-assets
          ls -lh
          uploads=""
          for file in *; do
            if [[ "${file}" = "stub-"* ]]; then
              echo "Skipping ${file} since it is a stub"
              continue
            fi
            aws s3 ls "${s3_dst}${file}"
            if [ $? -ne 0 ]; then
              aws s3 cp "${file}" "${s3_dst}" > /tmp/cmd-output 2>&1
              result=$?
              cat /tmp/cmd-output
              if [ $result -ne 0 ]; then
                slack -s error -m "Failed to upload substrate asset \`${file}\`" -f /tmp/cmd-output
                exit $result
              fi
              uploads="${uploads}\n${file}"
            fi
          done
          if [ "${uploads}" != "" ]; then
            echo -e "New substrate assets uploaded\n${uploads}"
          fi
    upload_assets: &UPLOAD_ASSETS
      run:
        name: Upload assets
        command: |
          set +e
          if [ "${CIRCLE_TAG}" != "" ]; then
            if [[ "${CIRCLE_TAG}" = *"+"* ]]; then
              s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
            else
              s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
            fi
          else
            sha=$(git rev-parse --short "${CIRCLE_SHA1}")
            s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH}/${sha}/"
          fi
          mkdir -p assets
          pushd ./assets
          ls -lh
          uploads=""
          for file in * ; do
            echo "Checking file: ${file}"
            if [[ "${file}" = "stub-"* ]]; then
              echo "Skipping ${file} since it is a stub"
              continue
            fi
            aws s3 ls "${s3_dst}${file}"
            if [ $? -ne 0 ]; then
              aws s3 cp "${file}" "${s3_dst}" > /tmp/cmd-output 2>&1
              result=$?
              cat /tmp/cmd-output
              if [ $result -ne 0 ]; then
                slack -s error -m "Failed to upload installer asset \`${file}\`" -f /tmp/cmd-output
                exit $result
              fi
              uploads="${uploads}\n${file}"
            fi
          done
          if [ "${uploads}" != "" ]; then
            echo -e "New installer assets uploaded\n${uploads}"
          fi
          exit
    substrate: &SUBSTRATE
      docker: *builder
      steps:
        - checkout
        - attach_workspace:
            at: .
        - *PACKET_SETUP_STEP
        - run:
            name: Build substrate
            no_output_timeout: 30m
            command: |
              set +e
              rm -f ./substrate-assets/*
              export SLACK_TITLE="Vagrant Packaging - Substrate ${PKT_VAGRANT_ONLY_BOXES}"
              substrates=$(<./circle-substrates-required)
              echo "Current list of missing substrates:"
              echo "${substrates}"
              while read sub; do
                if [ "${PKT_VAGRANT_ONLY_BOXES}" == "${sub}" ]; then
                  build=1
                fi
              done < ./circle-substrates-required
              if [ "${build}" != "1" ]; then
                echo "Substrate does not need to be built! - ${PKT_VAGRANT_ONLY_BOXES}"
                touch "./substrate-assets/stub-${CIRCLE_BUILD_NUM}"
                exit
              fi
              echo "Substrate not found - building ${PKT_VAGRANT_ONLY_BOXES}..."
              export PKT_VAGRANT_BUILD_TYPE="substrate"
              export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_WORKFLOW_ID}"
              pkg_dir="${CIRCLE_BUILD_NUM}"
              export PKT_VAGRANT_INSTALLER_VAGRANT_SUBSTRATE_OUTPUT_DIR="${pkg_dir}"
              packet-exec run -download "./${pkg_dir}/*:./substrate-assets" -- ./.runner-vmware.sh > /tmp/cmd-output 2>&1 &
              pid=$!
              until [ -f /tmp/cmd-output ]; do
                sleep 0.1
              done
              tail --quiet --pid $pid -f /tmp/cmd-output &
              wait $pid
              result=$?
              if [ $result -ne 0 ]; then
                slack -s error -m "Failed to build Vagrant substrate - ${CIRCLE_JOB}" -f /tmp/cmd-output -T 10
              fi
              exit $result
        - *PACKET_CLEANUP_STEP
        - *PACKET_FAILURE_STEP
        - *UPLOAD_SUBSTRATES
    package: &PACKAGE
      docker: *builder
      steps:
        - checkout
        - attach_workspace:
            at: .
        - *PACKET_SETUP_STEP
        - run:
            name: Build package
            no_output_timeout: 1h
            command: |
              set +e
              rm -f ./assets/*
              export SLACK_TITLE="Vagrant Packaging - Package ${PKT_VAGRANT_ONLY_BOXES}"
              packages=$(<./circle-packages-required)
              echo "Current list of missing packages:"
              echo "${packages}"
              while read pack; do
                if [ "${PKT_VAGRANT_ONLY_BOXES}" == "${pack}" ]; then
                  build=1
                fi
              done < ./circle-packages-required
              if [ "${build}" != "1" ]; then
                echo "Package does not need to be built! - ${PKT_VAGRANT_ONLY_BOXES}"
                touch "./assets/stub-${CIRCLE_BUILD_NUM}"
                exit
              fi
              echo "Package not found - building ${PKT_VAGRANT_ONLY_BOXES}..."
              pkg_dir="${CIRCLE_BUILD_NUM}"
              export PKT_VAGRANT_BUILD_TYPE="package"
              export PKT_VAGRANT_INSTALLER_VAGRANT_PACKAGE_OUTPUT_DIR="${pkg_dir}"
              export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_WORKFLOW_ID}"
              packet-exec run -download "./${pkg_dir}/*:./assets" -- ./.runner-vmware.sh > /tmp/cmd-output 2>&1 &
              pid=$!
              until [ -f /tmp/cmd-output ]; do
                sleep 0.1
              done
              tail --quiet --pid $pid -f /tmp/cmd-output &
              wait $pid
              result=$?
              mkdir -p assets
              if [ $result -ne 0 ]; then
                slack -s error -m "Failed to build Vagrant installer packages" -f /tmp/cmd-output -T 10
              fi
              exit $result
        - *PACKET_CLEANUP_STEP
        - *PACKET_FAILURE_STEP
        - *UPLOAD_ASSETS
jobs:
  load_gem:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Fetch Vagrant RubyGem
          command: |
            set +e
            if [ "${CIRCLE_TAG}" = "" ]; then
              aws s3 cp ${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/vagrant/vagrant-master.gem vagrant-master.gem > /tmp/cmd-output 2>&1
            else
              url=$(curl -SsL -H "Content-Type: application/json" "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/releases/tags/${CIRCLE_TAG}" | jq -r '.assets[] | select(.name | contains(".gem")) | .url')
              curl -H "Accept: application/octet-stream" -SsL -o "vagrant-${CIRCLE_TAG}.gem" "${url}" > /tmp/cmd-output 2>&1
            fi
            result=$?
            cat /tmp/cmd-output
            if [ $result -ne 0 ]; then
              slack -s error -m "Failed to download Vagrant RubyGem" -f /tmp/cmd-output
            fi
            exit $result
      - persist_to_workspace:
          root: .
          paths:
            - ./*.gem
  fetch_existing_packages:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Fetch previously built packages
          command: |
            set +e
            if [ "${CIRCLE_TAG}" != "" ]; then
              if [[ "${CIRCLE_TAG}" = *"+"* ]]; then
                s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              else
                s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              fi
            else
              sha=$(git rev-parse --short "${CIRCLE_SHA1}")
              s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH}/${sha}/"
            fi
            mkdir -p assets
            touch "./assets/stub-${CIRCLE_BUILD_NUM}"
            for name in $(aws s3 ls "${s3_dst}" | awk '{print $4}'); do
              touch "./assets/${name}"
            done
      - persist_to_workspace:
          root: .
          paths:
            - ./assets/*
  fetch_existing_substrates:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - checkout
      - run:
          name: Fetch previous builds
          command: |
            set +e
            sha=$(git rev-parse --short "${CIRCLE_SHA1}")
            s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${sha}/"
            mkdir -p substrate-assets
            touch "./substrate-assets/stub-${CIRCLE_BUILD_NUM}"
            for name in $(aws s3 ls "${s3_dst}" | awk '{print $4}'); do
              touch "./substrate-assets/${name}"
            done
      - persist_to_workspace:
          root: .
          paths:
            - ./substrate-assets/*
  required_substrate_guests:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Determine substrates to build
          command: |
            set +e
            declare -A list=(
              [*centos_x86_64.zip]="centos-6"
              [*centos_i686.zip]="centos-6-i386"
              [*darwin_x86_64.zip]="osx-10.9"
              [*ubuntu_x86_64.zip]="ubuntu-14.04"
              [*ubuntu_i686.zip]="ubuntu-14.04-i386"
              [*windows_x86_64.zip]="win-7"
              [*windows_i686.zip]="win-7"
            )
            touch circle-substrates-required
            for ptrn in "${!list[@]}"; do
              path=(substrate-assets/${ptrn})
              if [ ! -f "${path}" ]; then
                echo "${list[${ptrn}]}" >> circle-substrates-required
              fi
            done
            guests=$(<circle-substrates-required)
            echo "Substrates required for: ${guests}"
      - persist_to_workspace:
          root: .
          paths:
            - ./circle-substrates-required
  required_package_guests:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Determine packages to build
          command: |
            set +e
            declare -A list=(
              [*amd64.zip]="appimage"
              [*x86_64.tar.xz]="archlinux"
              [*x86_64.rpm]="centos-6"
              [*i686.rpm]="centos-6-i386"
              [*x86_64.dmg]="osx-10.9"
              [*x86_64.deb]="ubuntu-14.04"
              [*i686.deb]="ubuntu-14.04-i386"
              [*x86_64.msi]="win-7"
              [*i686.msi]="win-7"
            )
            touch circle-packages-required
            for ptrn in "${!list[@]}"; do
              path=(assets/${ptrn})
              if [ ! -f "${path}" ]; then
                echo "${list[${ptrn}]}" >> circle-packages-required
              fi
            done
            guests=$(<circle-packages-required)
            echo "Packages required for: ${guests}"
      - persist_to_workspace:
          root: .
          paths:
            - ./circle-packages-required
  packet_device:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Create packet device
          command: |
            set +e
            packet-exec info
            if [ $? -eq 0 ]; then
              exit
            fi
            unset PACKET_EXEC_SSH_KEY
            packet-exec create > /tmp/cmd-output 2>&1 &
            pid=$!
            until [ -f /tmp/cmd-output ]; do
              sleep 0.1
            done
            tail --quiet --pid $pid -f /tmp/cmd-output &
            wait $pid
            if [ $? -ne 0 ]; then
              slack -s error -m "Failed to create remote packet device" -f /tmp/cmd-output
            fi
            exit $result
  start_substrate_guests:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - checkout
      - attach_workspace:
          at: .
      - *PACKET_SETUP_STEP
      - run:
          name: Start packet guests
          command: |
            set +e
            guests=$(<./circle-substrates-required)
            if [ "${guests}" == "" ]; then
              echo "No substrates to build"
              exit
            fi
            rm -rf ./substrate-assets ./assets
            # package type will start all available guests
            guests="${guests//$'\n'/,}"
            echo "Substrates to build: ${guests}"
            export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_WORKFLOW_ID}"
            export PKT_VAGRANT_ONLY_BOXES="${guests}"
            export PKT_VAGRANT_BUILD_TYPE="substrate"
            # ensure there are no stray guests still running on the system
            packet-exec run -- pkill -f vmware-vmx
            packet-exec run -upload -- vagrant up --no-provision > /tmp/cmd-output 2>&1 &
            pid=$!
            until [ -f /tmp/cmd-output ]; do
              sleep 0.1
            done
            tail -f --quiet --pid $pid /tmp/cmd-output
            wait $pid
            result=$?
            if [ $result -ne 0 ]; then
              slack -s error -m "Failed to start builder guests on packet device" -f /tmp/cmd-output -T 10
            fi
            exit $result
      - *PACKET_CLEANUP_STEP
      - *PACKET_FAILURE_STEP
  start_package_guests:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - checkout
      - attach_workspace:
          at: .
      - *PACKET_SETUP_STEP
      - run:
          name: Restart packet guests
          no_output_timeout: 30m
          command: |
            set +e
            guests=$(<./circle-packages-required)
            if [ "${guests}" == "" ]; then
              echo "No packages to build"
              exit
            fi
            rm -rf ./assets
            echo "Loading any existing substrate assets..."
            sha=$(git rev-parse --short "${CIRCLE_SHA1}")
            s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${sha}/"
            aws s3 sync "${s3_dst}" ./substrate-assets/
            guests="${guests//$'\n'/,}"
            echo "Packages to build: ${guests}"
            # package type will start all available guests
            export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_WORKFLOW_ID}"
            export PKT_VAGRANT_BUILD_TYPE="package"
            # ensure there are no stray guests still running on the system
            packet-exec run -- pkill -f vmware-vmx
            packet-exec run -upload -- vagrant destroy --force > /tmp/cmd-output 2>&1 &
            pid=$!
            until [ -f /tmp/cmd-output ]; do
              sleep 0.1
            done
            tail -f --quiet --pid $pid /tmp/cmd-output
            wait $pid
            result=$?
            if [ $result -ne 0 ]; then
              echo "Guest destruction returned an error but continuing on anyway..."
            fi
            export PKT_VAGRANT_ONLY_BOXES="${guests}"
            packet-exec run -- vagrant up --no-provision > /tmp/cmd-output 2>&1 &
            pid=$!
            until [ -f /tmp/cmd-output ]; do
              sleep 0.1
            done
            tail -f --quiet --pid $pid /tmp/cmd-output
            wait $pid
            result=$?
            if [ $result -ne 0 ]; then
              slack -s error -m "Failed to start builder guests on packet device" -f /tmp/cmd-output -T 10
            fi
            exit $result
      - *PACKET_CLEANUP_STEP
      - *PACKET_FAILURE_STEP
  secrets_and_cleaner:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Provide secrets and cleanup
          command: |
            set +e
            echo -e -n "${PACKET_SSH_KEY}" > "${PACKET_EXEC_SSH_KEY}"
            chmod 600 "${PACKET_EXEC_SSH_KEY}"
            export PKT_VAGRANT_BUILD_TYPE="package"
            export PACKET_EXEC_PRE_BUILTINS="LoadSecrets"
            export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_WORKFLOW_ID}"
            packet-exec run -- "shopt -s nullglob; mkdir -p '/tmp/${CIRCLE_WORKFLOW_ID}'; f=(/tmp/${CIRCLE_WORKFLOW_ID}/*); until [ -f '/tmp/${CIRCLE_WORKFLOW_ID}/.halt' ] && [ \"${#f[*]}\" -eq 0 ]; do i=\$((i+1)); if [ \${i} -gt 120 ]; then i=0; echo -n '.'; fi; sleep 1; f=(/tmp/${CIRCLE_WORKFLOW_ID}/*); done"
            unset PACKET_EXEC_PERSIST
            unset PACKET_EXEC_PRE_BUILTINS
            packet-exec run -- "rm -rf '/tmp/${CIRCLE_WORKFLOW_ID}'; if [ -f Vagrantfile ]; then vagrant destroy -f; fi"
  clean_guests:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Clean packet guests
          command: *PACKET_FAILURE
  preapproval_notification:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - run:
          name: Notify of approval
          command: |
            slack -s warn -m "<@vagrant> - A new release is pending approval (*${CIRCLE_TAG}*):\n\n> https://circleci.hashicorp.engineering/workflow-run/${CIRCLE_WORKFLOW_ID}" -t "Vagrant Release Notification"
  sign_packages:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Sign packages
          no_output_timeout: 45m
          command: |
            set +e
            echo -e -n "${PACKET_SSH_KEY}" > "${PACKET_EXEC_SSH_KEY}"
            chmod 600 "${PACKET_EXEC_SSH_KEY}"
            echo "Fetching existing packages..."
            if [ "${CIRCLE_TAG}" != "" ]; then
              if [[ "${CIRCLE_TAG}" = *"+"* ]]; then
                s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              else
                s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              fi
            else
              sha=$(git rev-parse --short "${CIRCLE_SHA1}")
              s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH}/${sha}/"
            fi
            aws s3 sync "${s3_dst}" ./assets/
            rm -f ./assets/stub-*
            git clone https://github.com/hashicorp/vagrant vagrant
            mkdir -p vagrant/pkg/dist/
            mv assets/* vagrant/pkg/dist/
            pushd vagrant
            VERSION="${CIRCLE_TAG##v}"
            if [ "${VERSION}" == "" ]; then
              slack -s error -m "Failed to determine package version for signing"
              exit 1
            fi
            unset PACKET_PERSIST
            export PACKET_EXEC_PRE_BUILTINS="LoadSecrets"
            export PACKET_EXEC_REMOTE_DIRECTORY="${CIRCLE_BUILD_NUM}"
            packet-exec run -upload -download "./pkg/dist/*SHA256SUMS*:./assets" -- ./scripts/sign.sh ${VERSION}
            mv ./assets/* ../assets/
            ls -l ../assets
      - *UPLOAD_ASSETS
  release_packages:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Release Vagrant Packages
          command: |
            set +e
            if [ "${STUB_RELEASE}" != "" ]; then
              slack -m "Vagrant stub release complete (no-op) - *${CIRCLE_TAG}*"
              exit
            fi
            if [ "${CIRCLE_TAG}" != "" ]; then
              if [[ "${CIRCLE_TAG}" = *"+"* ]]; then
                s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              else
                s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
              fi
            else
              sha=$(git rev-parse --short "${CIRCLE_SHA1}")
              s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH}/${sha}/"
            fi
            aws s3 sync "${s3_dst}" ./assets/
            export AWS_ACCESS_KEY_ID="${RELEASE_AWS_ACCESS_KEY_ID}"
            export AWS_SECRET_ACCESS_KEY="${RELEASE_AWS_SECRET_ACCESS_KEY}"
            echo "Uploading to the releases site..."
            hc-releases upload ./assets > .output 2>&1 &
            pid=$!
            until [ -f .output ]; do
              sleep 0.1
            done
            tail -f --quiet --pid $pid .output
            wait $pid
            rm .output
            result=$?
            if [ $result -ne 0 ]; then
              slack -s error -m "Failed to upload new release!" -f .output -T 5
              exit 1
            fi
            echo "Publishing new release..."
            hc-releases publish > .output 2>&1 &
            pid=$!
            until [ -f .output ]; do
              sleep 0.1
            done
            tail -f --quiet --pid $pid .output
            wait $pid
            rm .output
            result=$?
            if [ $result -ne 0 ]; then
              slack -s error -m "Failed to publish release!" -f .output -T 5
              exit 1
            fi
            slack -m "New Vagrant release has been published! - *${CIRCLE_TAG}*\n\nAssets: ${s3_dst}"
  substrate_centos-6:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: centos-6
    <<: *SUBSTRATE
  substrate_centos-6-i386:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: centos-6-i386
    <<: *SUBSTRATE
  substrate_osx-10.9:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: osx-10.9
    <<: *SUBSTRATE
  substrate_ubuntu-14.04-i386:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: ubuntu-14.04-i386
    <<: *SUBSTRATE
  substrate_ubuntu-14.04:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: ubuntu-14.04
    <<: *SUBSTRATE
  substrate_win-7:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: win-7
    <<: *SUBSTRATE
  package_appimage:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: appimage
    <<: *PACKAGE
  package_archlinux:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: archlinux
    <<: *PACKAGE
  package_centos-6:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: centos-6
    <<: *PACKAGE
  package_centos-6-i386:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: centos-6-i386
    <<: *PACKAGE
  package_osx-10.9:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: osx-10.9
    <<: *PACKAGE
  package_ubuntu-14.04:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: ubuntu-14.04
    <<: *PACKAGE
  package_ubuntu-14.04-i386:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: ubuntu-14.04-i386
    <<: *PACKAGE
  package_win-7:
    environment:
      <<: *ENVIRONMENT
      PKT_VAGRANT_ONLY_BOXES: win-7
    <<: *PACKAGE
  prerelease_publish:
    environment:
      <<: *ENVIRONMENT
    docker: *builder
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run: |
          set +e
          if [ "${CIRCLE_TAG}" != "" ]; then
            if [[ "${CIRCLE_TAG}" = *"+"* ]]; then
              s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
            else
              s3_dst="${ASSETS_PRIVATE_BUCKET}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_TAG}/"
            fi
            TAG_NAME="${CIRCLE_TAG}"
          else
            sha=$(git rev-parse --short "${CIRCLE_SHA1}")
            s3_dst="${ASSETS_PRIVATE_LONGTERM}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BRANCH}/${sha}/"
          fi
          mkdir -p ./assets
          pushd assets
          for file in *; do
            if [[ "${file}" != "vagrant_"* ]]; then
              echo "Removing non-package file: ${file}"
              rm -f "${file}"
            fi
          done
          popd
          aws s3 sync "${s3_dst}" ./assets/
          echo "Asset list:"
          ls -lh ./assets
          echo "Start pre-release asset uploading..."
          export GITHUB_TOKEN="${HASHIBOT_TOKEN}"
          if [ "${TAG_NAME}" = "" ]; then
            v=(assets/vagrant*64.deb)
            v="${v#*_}"
            v="${v%%_*}"
            TAG_NAME="v${v}+${CIRCLE_BRANCH}"
            ghr -u ${CIRCLE_PROJECT_USERNAME} -r ${CIRCLE_PROJECT_REPONAME} -c ${CIRCLE_SHA1} -prerelease -delete -replace ${TAG_NAME} ./assets/ > .output 2>&1
          else
            ghr -u ${CIRCLE_PROJECT_USERNAME} -r ${CIRCLE_PROJECT_REPONAME} -c ${CIRCLE_SHA1} -prerelease -replace ${TAG_NAME} ./assets/ > .output 2>&1
          fi
          result=$?
          cat .output
          if [ $result -ne 0 ]; then
            slack -s error -m "Failed to upload installers assets to prerelease version ${TAG_NAME}"
            exit $result
          fi
          slack -m "New Vagrant development installers available:\n> https://github.com/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/releases/${TAG_NAME}"
          exit
workflows:
  version: 2
  package:
    jobs:
      - load_gem:
          <<: *DEFAULT_WORKFLOW
      - packet_device:
          <<: *DEFAULT_WORKFLOW
      - fetch_existing_substrates:
          <<: *DEFAULT_WORKFLOW
      - fetch_existing_packages:
          <<: *DEFAULT_WORKFLOW
      - required_substrate_guests:
          <<: *DEFAULT_WORKFLOW
          requires:
            - fetch_existing_substrates
      - required_package_guests:
          <<: *DEFAULT_WORKFLOW
          requires:
            - fetch_existing_packages
      - start_substrate_guests:
          <<: *DEFAULT_WORKFLOW
          requires:
            - packet_device
            - required_substrate_guests
      - substrate_centos-6:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - substrate_centos-6-i386:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - substrate_osx-10.9:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - substrate_ubuntu-14.04-i386:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - substrate_ubuntu-14.04:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - substrate_win-7:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_substrate_guests
      - package_appimage:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
      - package_archlinux:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
      - package_centos-6:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_centos-6
      - package_centos-6-i386:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_centos-6-i386
      - package_osx-10.9:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_osx-10.9
      - package_ubuntu-14.04-i386:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_ubuntu-14.04-i386
      - package_ubuntu-14.04:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_ubuntu-14.04
      - package_win-7:
          <<: *DEFAULT_WORKFLOW
          requires:
            - start_package_guests
            - substrate_win-7
      - secrets_and_cleaner:
          <<: *DEFAULT_WORKFLOW
          requires:
            - packet_device
      - start_package_guests:
          <<: *DEFAULT_WORKFLOW
          requires:
            - load_gem
            - required_package_guests
            - substrate_centos-6
            - substrate_centos-6-i386
            - substrate_osx-10.9
            - substrate_ubuntu-14.04-i386
            - substrate_ubuntu-14.04
            - substrate_win-7
      - clean_guests:
          <<: *DEFAULT_WORKFLOW
          requires:
            - package_appimage
            - package_archlinux
            - package_centos-6
            - package_centos-6-i386
            - package_osx-10.9
            - package_ubuntu-14.04
            - package_ubuntu-14.04-i386
            - package_win-7
      - sign_packages:
          <<: *RELEASE_WORKFLOW
          requires:
            - package_appimage
            - package_archlinux
            - package_centos-6
            - package_centos-6-i386
            - package_osx-10.9
            - package_ubuntu-14.04
            - package_ubuntu-14.04-i386
            - package_win-7
      - approve_release:
          <<: *RELEASE_WORKFLOW
          type: approval
          requires:
            - sign_packages
      - release_packages:
          <<: *RELEASE_WORKFLOW
          requires:
            - approve_release
      - preapproval_notification:
          <<: *RELEASE_WORKFLOW
          requires:
            - sign_packages
      - prerelease_publish:
          <<: *PRERELEASE_WORKFLOW
          requires:
            - package_appimage
            - package_archlinux
            - package_centos-6
            - package_centos-6-i386
            - package_osx-10.9
            - package_ubuntu-14.04
            - package_ubuntu-14.04-i386
            - package_win-7
